<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - morph targets - horse</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div id="container"></div>
<script src="three.js-master/build/three.js"></script>
<script src="three.js-master/examples/js/libs/stats.min.js"></script>
<script src="three.js-master/examples/js/controls/DragControls.js"></script>
<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
<script src="three.js-master/examples/js/libs/dat.gui.min.js"></script>
<script src="three.js-master/examples/js/exporters/OBJExporter.js"></script>
<script src="three.js-master/examples/js/loaders/OBJLoader.js"></script>
<script src="three.js-master/examples/js/loaders/BinaryLoader.js"></script>

<script src="modelLoader.js"></script>
<script src="createObjectAnimation.js"></script>

<script>
    var stats, camera, scene, projector, renderer, controls;
    var mesh, selected_object, settings;
    var vectors = [];
    var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});


    // Boolean for start and restart
    var theta = 0;
    var initAnim = true;
    var runAnim = false;
    var isPlay = false;

    init();
    animate();

    function init() {

        // SCENE
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // CAMERA
        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
        var VIEW_ANGLE = 50, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 1, FAR = 10000;
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        scene.add(camera);
        camera.position.set(0, 250, 800);

        var container = document.getElementById('container');

        // RENDERER
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container.appendChild(renderer.domElement);

        //CONTROLS
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render);
        var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
        dragControls.addEventListener('dragstart', function (event) {
            controls.enabled = false;
        });

        dragControls.addEventListener('dragend', function (event) {
                controls.enabled = true;
                if (event.object.material ===  sphereMaterial) {
                    var array = object_trajectories[selected_object.name];
                    var sphereGroup = array[array.length - 1]["sphereGroup"];
                    var vectors = [];
                    for (var i = 0; i < sphereGroup.children.length; i++) {
                        var point1 = sphereGroup.children[i].position;
                        vectors.push(point1);
                    }

                    if (vectors.length > 1) {

                        var line = array[array.length - 1]["line"];

                        var curve = new THREE.CatmullRomCurve3(vectors);
                        var points = curve.getPoints(numPoints);
                        var geometry = new THREE.Geometry();
                        for (var i = 0; i < points.length; i++) {
                            geometry.vertices.push(points[i]);
                        }
                        var curveObject = new THREE.Line(geometry, lineMaterial);

                        if (line === null) {
                            scene.add(curveObject);
                            array[array.length - 1]["line"] = curveObject;
                        }

                        else {
                            array[array.length - 1]["line"] = curveObject;
                            animate();
                        }
                    }
                }


                //console.log(event.object.position);
            }
        );

        //LIGHTS
        var light = new THREE.DirectionalLight(0xefefff, 1.5);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        light = new THREE.DirectionalLight(0xffefef, 1.5);
        light.position.set(-1, -1, -1).normalize();
        scene.add(light);

        light = new THREE.PointLight(0xffffff);
        light.position.set(0, 250, 0);
        scene.add(light);

        // STATS
        stats = new Stats();
        container.appendChild(stats.dom);

        // FLOOR
        var floorGeometry = new THREE.PlaneGeometry(9000, 9000, 100, 100);
        floorGeometry.rotateX(-Math.PI / 2);
        for (var i = 0, l = floorGeometry.vertices.length; i < l; i++) {
            var vertex = floorGeometry.vertices[i];
            vertex.x += Math.random() * 20 - 10;
            vertex.y += Math.random() * 2;
            vertex.z += Math.random() * 20 - 10;
        }
        for (var i = 0, l = floorGeometry.faces.length; i < l; i++) {
            var face = floorGeometry.faces[i];
            face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
        }

        var floorMaterial = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -1;
        floor.name = 'floor';
        selected_object = floor;
        scene.add(floor);

        createPanel();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize, false);

    function createPanel() {
        var panel = new dat.GUI({width: 270});
        var folder1 = panel.addFolder('Add model');
        var folder2 = panel.addFolder('Animation');

        settings = {
            'horse': addHorse,
            'flamingo': addFlaming,
            'parrot': addParrot,
            'stork': addStork,
            'box': addBox,
            'earth': addEarth,
            'veyron': addVeyron,
            'camaro': addCamaro,
            'gallardo': addGallardo,
            'f50': addF50,
            'import model': "",
            'wireframe': false,
            'start/pause': StartAnimation,
            'create trajectory': createTrajectory,
            'geometry': 'Cube',
            'rotation_x': 1,
            'rotation_y': 1,
            'rotation_z': 1,
            'name': selected_object.name,
            'scale': 0.5
        };
        var step = 0.1;
        folder1.add(settings, 'horse');
        folder1.add(settings, 'flamingo');
        folder1.add(settings, 'parrot');
        folder1.add(settings, 'stork');
        folder1.add(settings, 'box');
        folder1.add(settings, 'earth');
        folder1.add(settings, 'veyron');
        folder1.add(settings, 'camaro');
        folder1.add(settings, 'gallardo');
        folder1.add(settings, 'f50');

        folder1.add(settings, 'scale').min(0.01).max(15).step(0.01).name('scale').onChange(function (value) {
            setScale(value)
        });
        //folder1.add( settings,  'import model').onChange(function(value){addUserModel(value)});
        folder1.open();

        folder2.add(settings, 'start/pause');
        folder2.add(settings, 'create trajectory');

        folder2.add(settings, 'rotation_x').min(-10).max(10).step(step).name('Rotation X axis').onChange(render);
        folder2.add(settings, 'rotation_y').min(-10).max(10).step(step).name('Rotation Y axis').onChange(render);
        folder2.add(settings, 'rotation_z').min(-10).max(10).step(step).name('Rotation Z axis').onChange(render);
        //folder2.open();

        var folder3 = panel.addFolder('Selected object settings');
        folder3.add(settings, 'name').listen();
        folder3.add(settings, 'wireframe').onChange(function (value) {
            selected_object.material.wireframe = value;
        });

        folder3.open();

        var folder4 = panel.addFolder('Create object');

        //meter cores e assim?? ou não permitimos criar objeos pela gui MATOS?

        folder4.add(settings, 'geometry', ['Cube', 'Sphere', 'Torus']).onChange(render);
        folder4.open();
    }

    function StartAnimation() {
        if (initAnim) {
            initAnim = false;
            runAnim = true;
            theta = 0;
        }

        // Start and Pause
        if (runAnim) {
            runAnim = false;
            isPlay = true;
            theta = 0.1;
        }

        else {
            runAnim = true;
            isPlay = false;
            theta = 0;
        }
    }

    //mouse event variables
    var projector = new THREE.Projector();
    mouse_vector = new THREE.Vector3();
    mouse = {x: 0, y: 0, z: 1};
    ray = new THREE.Raycaster(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
    intersects = [];

    // Para perspectiveCamera
    function onMouseDown(e) {
        switch (e.button) {
            case 0: // butão esquerdo

                //Evita que o evento chame outra função
                e.preventDefault();
                //Começa a tranformação entre coordenadas do rato e three.js
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                //Vector 3D que indica a direção do vetor a partir do pixel
                mouse_vector.set(mouse.x, mouse.y, mouse.z);
                //Define um ponto no espaço 3D de acordocom o clique do rato
                projector.unprojectVector(mouse_vector, camera);
                var direction = mouse_vector.sub(camera.position).normalize();
                //Chama o raycaster com a posição da câmara e a direção
                ray.set(camera.position, direction);

                //Verifica se o raio intersetou algum objeto na cena
                intersects = ray.intersectObjects(scene.children);
                if (intersects[0].object.material !==  sphereMaterial) {
                    selected_object = intersects[0].object;
                    //alert(selected_object.name);
                    settings.name = selected_object.name;
                }
                break;

            case 2: // botão direito
                e.preventDefault();
                var geometry = new THREE.SphereGeometry(10, 32, 32);
                var sphere = new THREE.Mesh(geometry, sphereMaterial);
                sphere.position.set(0, 200, 0);

                if (object_trajectories[selected_object.name] === undefined) {
                    var group = new THREE.Group();
                    group.add(sphere);
                    object_trajectories[selected_object.name] = [{sphereGroup: group, line: null}];
                }

                else {
                    var array = object_trajectories[selected_object.name];
                    var group = array[array.length - 1]["sphereGroup"];
                    group.add(sphere);
                    array[array.length - 1]["sphereGroup"] = group;
                    alert(array[array.length - 1]["sphereGroup"].children.length);
                }

                console.log(object_trajectories);
                scene.add(sphere);
                objects.push(sphere);
                break;
        }
    }

    /*

    "cars": {
        [
        "obj1": {
            "traj2": {"shpere":4, "line":"automatic"},
            "traj1": {"doors":4, "transmission":"automatic"}
        },
        "Ford": {
            "Taurus": {"doors":4, "transmission":"automatic"},
            "Escort": {"doors":4, "transmission":"automatic"}
        }
        ]

    */

    renderer.domElement.addEventListener('mousedown', onMouseDown);

    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
    }

    var radius = 600;
    var prevTime = Date.now();

    function render() {
        if (isPlay)
            playAnimations();

        renderer.render(scene, camera);
        //controls.update();
    }

    function playAnimations() {
        if (selected_object) {
            selected_object.rotation.y += theta;
        }

        if (mixers.length > 0) {

            var time = Date.now();
            for (var i = 0; i < mixers.length; i++) {
                mixers[i].update(( time - prevTime ) * 0.001);
            }
            prevTime = time;
        }
    }


    /*
    var spline = new THREE.SplineCurve3([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0, 200, 0),
    new THREE.Vector3(150, 150, 0),
    new THREE.Vector3(150, 50, 0),
    new THREE.Vector3(250, 100, 0),
    new THREE.Vector3(250, 300, 0)
]);

var material = new THREE.LineBasicMaterial({
color: 0xff00f0,
});

var geometry = new THREE.Geometry();
var splinePoints = spline.getPoints(numPoints);

for(var i = 0; i < splinePoints.length; i++){
geometry.vertices.push(splinePoints[i]);
}

var line = new THREE.Line(geometry, material);
scene.add(line);

*/

</script>
</body>
</html>
