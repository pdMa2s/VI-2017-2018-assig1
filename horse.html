<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three Animator </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div id="container"></div>
<script src="three.js-master/build/three.js"></script>
<script src="three.js-master/examples/js/libs/stats.min.js"></script>
<script src="three.js-master/examples/js/controls/DragControls.js"></script>
<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
<script src="three.js-master/examples/js/libs/dat.gui.min.js"></script>
<script src="three.js-master/examples/js/exporters/OBJExporter.js"></script>
<script src="three.js-master/examples/js/loaders/OBJLoader.js"></script>
<script src="three.js-master/examples/js/loaders/BinaryLoader.js"></script>
<script src="ObjectCollection.js"></script>
<script src="modelLoader.js"></script>
<script src="SceneObject.js"></script>
<script src="Animation.js"></script>
<script src="createObjectAnimation.js"></script>
<script src="Animator.js"></script>


<script>
    var stats, camera, scene, projector, renderer, controls;
    var mesh, selected_object, settings;
    var vectors = [];
    var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    var clock = new THREE.Clock();
    var secondsPassed;


    // Boolean for animationStart and restart
    var theta = 0;
    var initAnim = true;
    var runAnim = false;
    var isPlay = false;

    init();
    animate();

    function init() {

        // SCENE
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // CAMERA
        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
        var VIEW_ANGLE = 50, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 1, FAR = 10000;
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        scene.add(camera);
        camera.position.set(0, 250, 800);

        var container = document.getElementById('container');

        // RENDERER
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container.appendChild(renderer.domElement);

        //CONTROLS
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render);
        var dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
        dragControls.addEventListener('dragstart', function (event) {
            controls.enabled = false;
        });

        dragControls.addEventListener('dragend', function (event) {
                controls.enabled = true;
                /*
               if (event.object.material ===  sphereMaterial) {
                   var array = object_trajectories[selected_object.name];
                   var spheres = array[array.length - 1]["spheres"];
                   var vectors = [];
                   for (var i = 0; i < spheres.children.length; i++) {
                       var point1 = spheres.children[i].position;
                       vectors.push(point1);
                   }

                   if (vectors.length > 1) {

                       var line = array[array.length - 1]["line"];

                       var curve = new THREE.CatmullRomCurve3(vectors);
                       var points = curve.getPoints(numPoints);
                       var geometry = new THREE.Geometry();
                       for (var i = 0; i < points.length; i++) {
                           geometry.vertices.push(points[i]);
                       }
                       var curveObject = new THREE.Line(geometry, lineMaterial);

                       if (line === null) {
                           scene.add(curveObject);
                           array[array.length - 1]["line"] = curveObject;
                       }

                       else {
                           array[array.length - 1]["line"] = curveObject;
                           animate();
                       }
                   }
               }
               */

                objCollection.setPosition(selected_object.name, selected_object.position);
            }
        );

        //LIGHTS
        var light = new THREE.DirectionalLight(0xefefff, 1.5);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);

        light = new THREE.DirectionalLight(0xffefef, 1.5);
        light.position.set(-1, -1, -1).normalize();
        scene.add(light);

        light = new THREE.PointLight(0xffffff);
        light.position.set(0, 250, 0);
        scene.add(light);
        selected_object = light;

        // STATS
        stats = new Stats();
        container.appendChild(stats.dom);


        // FLOOR
        var floorGeometry = new THREE.PlaneGeometry(9000, 9000, 100, 100);
        floorGeometry.rotateX(-Math.PI / 2);
        for (var i = 0, l = floorGeometry.vertices.length; i < l; i++) {
            var vertex = floorGeometry.vertices[i];
            vertex.x += Math.random() * 20 - 10;
            vertex.y += Math.random() * 2;
            vertex.z += Math.random() * 20 - 10;
        }
        for (var i = 0, l = floorGeometry.faces.length; i < l; i++) {
            var face = floorGeometry.faces[i];
            face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
        }

        var floorMaterial = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -1;
        floor.name = 'floor';
        selected_object = floor;
        scene.add(floor);

        createPanel();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize, false);

    function createPanel() {
        var panel = new dat.GUI({width: 270});
        var folder1 = panel.addFolder('Add model');
        var folder5 = panel.addFolder('Import models');
        var folder2 = panel.addFolder('Animation');

        settings = {
            'horse': addHorse,
            'flamingo': addFlamingo,
            'parrot': addParrot,
            'stork': addStork,
            'box': addBox,
            'earth': addEarth,
            'veyron': addVeyron,
            'camaro': addCamaro,
            'gallardo': addGallardo,
            'f50': addF50,
            'wireframe': false,
            'start/pause': StartAnimation,
            'create/save trajectory': createTrajectory,
            'geometry': 'Cube',
            'rotation_x': 0,
            'rotation_y': 0,
            'rotation_z': 0,
            'name': selected_object.name,
            'scale': 0.5,
            'startTime': 0,
            'endTime': 0,
            'add Rotation': createRotation,
            'import obj': "",
            'import json': ""
        };

        folder1.add(settings, 'horse');
        folder1.add(settings, 'flamingo');
        folder1.add(settings, 'parrot');
        folder1.add(settings, 'stork');
        folder1.add(settings, 'box');
        folder1.add(settings, 'earth');
        folder1.add(settings, 'veyron');
        folder1.add(settings, 'camaro');
        folder1.add(settings, 'gallardo');
        folder1.add(settings, 'f50');

        folder1.add(settings, 'scale').min(0.01).max(15).step(0.01).name('scale').onChange(function (value) {
            setScale(value)
        });
        //folder1.add( settings,  'import model').onChange(function(value){addUserModel(value)});


        folder5.add(settings, 'import json').onChange(function (value) {
            addJsonModel(value, "Jmodel");


        });
        folder5.add(settings, 'import obj').onChange(function (value) {
            addObjModel(value);
        });


        //folder1.open();
        var step = 0.0001;
        folder2.add(settings, 'start/pause');
        folder2.add(settings, 'startTime').name('Start time').onChange(function (value) {
            animationStart = value;
        });
        folder2.add(settings, 'endTime').name('End time').onChange(function (value) {
            animationEnd = value;
        });
        folder2.add(settings, 'create/save trajectory');
        folder2.add(settings, 'rotation_x').min(-1).max(1).step(step).name('Rotation X axis').onChange(function (value) {
            rX = value;
        });
        folder2.add(settings, 'rotation_y').min(-1).max(1).step(step).name('Rotation Y axis').onChange(function (value) {
            rY = value;
        });
        folder2.add(settings, 'rotation_z').min(-1).max(1).step(step).name('Rotation Z axis').onChange(function (value) {
            rZ = value;
        });
        folder2.add(settings, 'add Rotation');
        //folder2.open();

        var folder3 = panel.addFolder('Selected object settings');
        folder3.add(settings, 'name').listen();
        folder3.add(settings, 'wireframe').onChange(function (value) {
            selected_object.material.wireframe = value;
        });

        //folder3.open();

        var folder4 = panel.addFolder('Create object');

        //Tirar
        //meter cores e assim?? ou não permitimos criar objeos pela gui MATOS?

        folder4.add(settings, 'geometry', ['Cube', 'Sphere', 'Torus']).onChange(render);
        //folder4.open();
    }

    //mouse event variables
    projector = new THREE.Projector();
    mouse_vector = new THREE.Vector3();
    mouse = {x: 0, y: 0, z: 1};
    ray = new THREE.Raycaster(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
    intersects = [];

    // Para perspectiveCamera
    function onMouseDown(e) {
        switch (e.button) {
            case 0: // botão esquerdo
                //Evita que o evento chame outra função
                e.preventDefault();

                if (!creatingTrajectory) {
                    //Começa a tranformação entre coordenadas do rato e three.js
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    //Vector 3D que indica a direção do vetor a partir do pixel
                    mouse_vector.set(mouse.x, mouse.y, mouse.z);
                    //Define um ponto no espaço 3D de acordocom o clique do rato
                    projector.unprojectVector(mouse_vector, camera);
                    var direction = mouse_vector.sub(camera.position).normalize();
                    //Chama o raycaster com a posição da câmara e a direção
                    ray.set(camera.position, direction);

                    //Verifica se o raio intersetou algum objeto na cena
                    intersects = ray.intersectObjects(scene.children);
                    if (intersects[0].object.material !== sphereMaterial && intersects[0].object !== 'floor') {
                        selected_object = intersects[0].object;
                        settings.name = selected_object.name;
                    }
                }

                break;

            case 2: // botão direito
                e.preventDefault();
                if (creatingTrajectory) {
                    var geometry = new THREE.SphereGeometry(10, 32, 32);
                    var sphere = new THREE.Mesh(geometry, sphereMaterial);

                    sphere.position.set(0, 200, 0);
                    trajPositions.push(sphere);
                    objects.push(sphere);
                    scene.add(sphere);
                }
                break;
        }
    }

    renderer.domElement.addEventListener('mousedown', onMouseDown);

    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
    }

    var timeBeforeAnimation = 0;

    function updateTimeBefore() {
        timeBeforeAnimation = Date.now();
    }

    var prevTime = Date.now();
    var t = 0;

    var up = new THREE.Vector3(0, 1, 0);
    var axis = new THREE.Vector3();
    var pt, radians, axis, tangent;

    function render() {
        secondsPassed = clock.getElapsedTime();
        var object = selected_object;

        if (isPlay) {
            playAnimations();
        }

        /*
        if (t === 0) {
            console.log("OBJECT INITIAL POS");
            console.log(object.position);
        }


        // teste só para 1 trajetoria
        if (t < 1) {
            var spline = object_trajectories[object.name][0]['line'];


            // set the marker position
            //object.position.copy(spline.getPointAt(t));
            pt = spline.getPointAt(t);
            console.log("PT");
            console.log(pt);
            object.position.set(pt.x, pt.y, pt.z);
            console.log("OBJECT POS");
            console.log(object.position);

            // get the tangent to the curve
            tangent = spline.getTangent(t).normalize();

            // calculate the axis to rotate around
            //axis.crossVectors(up, tangent).normalize();

            // calcluate the angle between the up vector and the tangent
            radians = Math.acos(up.dot(tangent));

            // set the quaternion
            object.quaternion.setFromAxisAngle(axis, radians);
            t += 0.005;
            // 60fps -> 60 incrementos - 1 segundo
            // 3 segundos - 180 incrementos  t = [0,1]  1 / 180 = 0.005555555555555556
        }
        */
        renderer.render(scene, camera);
        //controls.update();
    }

    var sortedAnimations = [];
    var animationWorkers = [];

    function StartAnimation() {
        if (initAnim) {
            initAnim = false;
            runAnim = true;
            theta = 0;
        }

        // Start and Pause
        if (runAnim) {
            runAnim = false;
            isPlay = true;
            theta = 0.1;
            sortedAnimations = objCollection.getSortedAnimations();
            updateTimeBefore();
        }

        else {
            runAnim = true;
            isPlay = false;
            theta = 0;
            for (let i = 0; i < animationWorkers.length; i++) {
                animationWorkers[i].terminate();
            }
            animationWorkers = [];
        }
    }

    var nextAnimation = 0;
    var animationToPlay;

    function playAnimations() {

        if (nextAnimation < sortedAnimations.length) {
            animationToPlay = sortedAnimations[nextAnimation];
            if (play(timeBeforeAnimation, animationToPlay)) {
                nextAnimation++;
                updateTimeBefore();
            }

        }
        //alert("launch worker");
        //let w = new Worker("AnimationPlayer.js");
        //w.postMessage(animationToPlay);
        //animationWorkers.push();


        if (mixers.length > 0) {

            var time = Date.now();
            for (var i = 0; i < mixers.length; i++) {
                mixers[i].update(( time - prevTime ) * 0.001);
            }
            prevTime = time;
        }
    }

</script>
</body>
</html>
